<!DOCTYPE html>
<html>
  <head>
    <title>Graphs - Version 3</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <link rel="stylesheet" href="fullscreen.css" />
    <script
      src="https://kit.fontawesome.com/c5e502ac44.js"
      crossorigin="anonymous"
    ></script>
    <link rel="stylesheet" href="mathquill-0.10.1/mathquill.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
    <script src="mathquill-0.10.1/mathquill.js"></script>
    <script type="text/javascript" src="js/paper.js"></script>
    <script type="text/paperscript" canvas="myCanvas">
      var verbose = true;
      var hitResult, activeItem, selectedItems = [];
      var backLayer, contentLayer;
      var protos = {
        point: new Path.Circle({
          center: new Point(0,0),
          radius: 3,
          fillColor: "black",
          strokeColor: "black",
          strokeWidth: 1,
          dashArray: null,
          data: {type: "Pointy",},
        }),
        disc: new Path.Circle({
          center: new Point(0,0),
          radius: 1,
          fillColor: "black",
          strokeColor: "black",
          strokeWidth: 1,
          dashArray: null,
          strokeScaling: false,
          data: {type: "Disc", shiftable: true,},
        }),
        rect: new Path.Rectangle({
          point: new Point(0,0),
          size: new Size(1,1),
          fillColor: "black",
          strokeColor: "black",
          strokeWidth: 1,
          dashArray: null,
          strokeScaling: false,
          data: {type: "Rectangle", resizeable: true, shiftable: true,},
        }),
        arrow: new Path({
          segments: [new Point(-10,4), new Point(0,0), new Point(-10,-4)],
          pivot: new Point(0,0),
          strokeColor: "black",
          strokeWidth: 1,
          applyMatrix: false,
          locked: true,
        }),
        tick: new Path({
          segments: [new Point(0,-4), new Point(0,4)],
          strokeColor: "red",
          strokeWidth: 1,
          applyMatrix: false,
          locked: true,
        }),
        dash: [10,12],
        colorHSLa: new Color({
          hue: 140,
          saturation: 1,
          lightness: 0.4,
          alpha: 0.7
        }),
      };
      var helpers = {
        setGlobals: function() {
          globals.getStyleById = function(id) {
            var myItem = project.getItem({id: id});
            if (!myItem) {
              console.log("No item.");
              return null;
            }
            return myItem.style;
          }
          globals.refreshCanvas = function() {
            project.clear();
            loadCanvas();
          };
          globals.setProps = function(id, props) {
            var item = project.getItem({id: id});
            item.set(props);
          };
          globals.colorHSL = protos.colorHSLa;
        },
        createBackground: function() {
          // Make sure this goes into the correct layer.
          var backLayer = project.layers[0];
          console.log("Back layer: ", backLayer);
          backLayer.name = "backgroundLayer";
          backLayer.activate();
          var whiteBackground = new Path.Rectangle({
            rectangle: view.bounds,
            fillColor: "white",
            strokeColor: "white",
            locked: true,
          });
          var gridSize = view.bounds.size / new Size(72,72);
          project.currentStyle = {
            strokeColor: "lightblue",
          };
          for (var i=0; i<gridSize.width; i++) {
            var x = i*72;
            var gLine = new Path.Line(new Point(x, view.bounds.top), new Point(x, view.bounds.bottom));
          }
          for (var i=0; i<gridSize.height; i++) {
            var y = i*72;
            var gLine = new Path.Line(new Point(view.bounds.left, y), new Point(view.bounds.right, y));
          }
          contentLayer = new Layer();
          contentLayer.activate();
        },
        clearVariables: function() {
          return null;
        }, // Not implemented.
        getCharacter: function(index, alphabet) {
          var char;
          if (alphabet === "Greek") {
            char = String.fromCharCode(913+index);
          } else if (alphabet === "greek") {
            char = String.fromCharCode(945+index);
          } else if (alphabet === "Latin") {
            char = String.fromCharCode(65+index);
          } else if (alphabet === "latin") {
            char = String.fromCharCode(97+index);
          }
          return char;
        },
        boundaryPoint: function(item, pt2, args) {
          if (item.className === "Point") {
            return item;
          }
          if (item.bounds.contains(pt2)) {
            return pt2;
          }
          var boundPath = new Path.Rectangle(item.bounds);
          boundPath.scale((item.bounds.size + new Size(10,10))/item.bounds.size);
          if (args && args.padding) {
            boundPath.scale((item.bounds.size+args.padding*2)/item.bounds.size);
          }
          var seg = new Path.Line(item.position, pt2);
          var intersections = boundPath.getIntersections(seg);
          boundPath.remove();
          seg.remove();
          return (intersections[0] ? intersections[0].point : item.position);
        },
        addDependency: function(owner, decor, args) {
          var point;
          if (args && (args.curveTime || args.curveTime == 0)) {
            point = owner.getPointAt(args.curveTime*owner.length);
            decor.data.curveTime = args.curveTime;
          } else {
            point = owner.point ? owner.point : owner.position;
          }
          if (decor.className === "PointText") {
            decor.data.shift = args ? args.shift : new Point(0,0);
            owner.data.label.content = decor.content;
          }
          if (!decor.applyMatrix) {
            var vector = owner.getTangentAt(args.curveTime);
            decor.rotate(vector.angle);
          }
          decor.position = point;
          decor.data.owner = owner;
          if (!owner.data.dependents) {
            owner.data.dependents = [];
          }
          owner.data.dependents.push(decor);
          return decor;
        },
        updateDependency: function(decor, args) {
          var point, vec;
          if (decor.data.n1 || decor.data.n2) {
            if (decor.data.n1) {
              var seg = decor.firstSegment;
              decor.firstSegment.point = helpers.boundaryPoint(decor.data.n1, seg.next.point);
              //decor.smooth();
            }
            if (decor.data.n2) {
              var seg = decor.lastSegment;
              decor.lastSegment.point = helpers.boundaryPoint(decor.data.n2, seg.previous.point);
              //decor.smooth();
            }
          } else if (decor.data.endpoints) {
            decor.firstSegment.point = helpers.boundaryPoint(decor.data.endpoints[0], decor.firstSegment.next.point);
            decor.lastSegment.point = helpers.boundaryPoint(decor.data.endpoints[1], decor.lastSegment.previous.point);
            //decor.smooth();
            return;
          } else if (decor.data.owner) {
            var owner = decor.data.owner;
            var shift = decor.data.shift ? decor.data.shift : new Point(0,0);
            if (decor.data.curveTime) {
              point = owner.getPointAt(decor.data.curveTime*owner.length) + shift;
              vec = owner.getTangentAt(decor.data.curveTime*owner.length);
            } else {
              point = (owner.point ? owner.point : owner.position) + shift;
            }
            if (decor.point) {
              decor.point = point;
            } else {
              decor.position = point;
            }
            if (vec && !decor.applyMatrix) {
              var rotationPrev = decor.rotation;
              decor.rotate(vec.angle - rotationPrev);
            }
            if (args && args.updateColor) {
              decor.strokeColor = decor.data.owner.strokeColor;
              if (decor.fillColor) {
                decor.fillColor = decor.strokeColor;
              }
            }
          }
          if (decor.data.dependents) {
            helpers.updateAllDependents(decor);
          }
        },
        updateAllDependents: function(item) {
          if (!item.data.dependents) {
            return;
          }
          for (var i=0; i < item.data.dependents.length; i++) {
            helpers.updateDependency(item.data.dependents[i]);
          }
        },
        lineFromTo: function(item1, item2) {
          var items = [item1, item2];
          var lineSeg;
          var point1 = helpers.boundaryPoint(items[0], items[1].position);
          var point2 = helpers.boundaryPoint(items[1], items[0].position);
          lineSeg = new Path([point1, point2]);
          return lineSeg;
        },
        mapsTo: function (item1, item2) { // FIXME: Implement decorate path.
          var line = helpers.lineFromTo(item1, item2);
          var arrowTip = protos.arrow.clone();
          var crossBar = protos.tick.clone();
          decoratePath(line, arrowTip, {curveTime: 1});
          decoratePath(line, crossBar, {curveTime: 0});
          return line;
        },
        decorate: function(path, decor, args) {
          return;
        },
        getReflectionMatrix: function(angle, scale) {
          angle *= Math.PI/180;
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          return new Matrix(c*c+scale*s*s, (1-scale)*c*s, (1-scale)*c*s, s*s + scale*c*c,0,0);
        },
        getRotationMatrix: function(angle) {
          angle *= Math.PI/180;
          var c = Math.cos(angle);
          var s = Math.sin(angle);
          return new Matrix(c,-s,s,c,0,0);
        },
        transformItem: function(item, matrix, point) {
          var shift = point ? point : item.position;
          item.position -= shift;
          item.transform(matrix);
          item.position += shift;
        },
        saveState: function(item) {
          if (item.writeState) {
            item.writeState();
            return;
          }
          if (!item.data.history) {
            item.data.history = [];
          }
          var state;
          if (item.children) {
            state = {};
            for (var i=0; i < item.children.length; i++) {
              state[item.children[i].id] = helpers.saveState(item.children[i]);
            }
          } else {
            state = item.exportJSON();
          }
          item.data.history.push(state);
          return (item.data.history.length-1);
        },
        loadState: function(target, index) {
          // If target has no history in its data, do nothing. Return.
          if (!target.data.history) {
            return null;
          }
          var hist = target.data.history;
          index = (index < 0) ? 0 : (index >= hist.length) ? hist.length : index;
          var state = hist[index];
          if (target.importState) {
            target.importState(index);
          }
          // If the index is greater than the history length, use the last index.

          // If the target item has a special load function, use that.
          // Else if the state is a JSON, import it to the target item.
          // Else if the state is an object, loop through the keys (IDs of children).
          // If no child with the given ID exists, create and add it.
          // If the associated value is a JSON, import it. (This shouldn't happen.)
          // Else if it is an integer, recursively use load state on the child and integer.
        },
        linearLayour: function() { // Not implemented.
          return;
        },
        toDisplayString: function(item) {
          if (item.children) {
            for (var i=0; i<item.children.length; i++) {
              helpers.toDisplayString(item.children[i]);
            }
          } else {
            var myType = item.data.type ? item.data.type : item.className;
            var dispString = myType + " (@" + item.id +")";
            if (item.className === "PointText") {
              dispString += ": " + item.content;
            }
            globals.newCalcEntry(item.id, dispString);
          }
        },
      };
      var handlers = {
        dragToMove: function(event) {
          if (!activeItem) {
            return;
          }
          if (activeItem.className === "Segment") {
            activeItem.point += event.delta;
            helpers.updateDependency(activeItem.path);
            activeItem.smooth();
          } else {
            activeItem.position += event.delta;
          }
          var toUpdate = activeItem.path ? activeItem.path : activeItem;
          if (toUpdate.data && toUpdate.data.dependents) {
            helpers.updateAllDependents(toUpdate);
          }
        },
        dragToDraw: function(event) {
          if (!activeItem) {
            return null;
          }
          activeItem.add(event.point);
        },
        dragToScale: function(event) { // Not implemented. Decisions to make.
          return;
        },
        dragToResize: function(event) {
          if (!hitResult) {
            return;
          }
          // If name ends in -center, only scale in one direction (about the opposite edge).
          // Otherwise, scale about the opposite corner.
          var oppCorner = basics.oppositeCorners[hitResult.name];
          return null;
        },
        dragToRotate: function(event) {
          if (activeItem.applyMatrix) {
            return;
          }
          var startAngle = (event.point - event.delta - activeItem.position).angle;
          var currentAngle = (event.point-activeItem.position).angle;
          activeItem.rotate(currentAngle - startAngle);
        },
        upToClear: function(event) { // Not implemented.
          return;
        },
      };
      var basics = {
        hitOptions: {
          fill: true,
          stroke: true,
          segments: true,
          bounds: true,
          center: true,
          handles: true,
          tolerance: 5,
        },
        oppositeCorners: {
          "top-center": "bottom-center",
          "bottom-center": "top-center",
          "right-center": "left-center",
          "left-center": "right-center",
          "top-left": "bottom-right",
          "top-right": "bottom-left",
          "bottom-right": "top-left",
          "bottom-left": "top-right",
        },
      };
      var styles = {
        text: {
          fillColor: "black",
          strokeColor: "null",
          strokeWidth: 1,
          dashArray: null,
          fontFamily: "Arial",
          strokeJoin: "round",
        },
        stroke: {
          fillColor: null,
          strokeColor: "black",
          strokeWidth: 1,
        },
        sketch: {
          fillColor: null,
          strokeColor: "black",
          strokeWidth: 2,
          dashArray: null,
        },
      };
      var diagrams = {
        snake: [["", "0", "0", "0", ""],
                                 ["0", "ker(a)", "ker(b)", "ker(c)", ""],
                                 ["0", "A", "B", "C", "0"],
                                 ["0", "A'", "B'", "C'", "0"],
                                 ["", "coker(a)", "coker(b)", "coker(c)", ""],
                                 ["", "0", "0", "0", ""]
                              ],
        five: [["A", "B", "C", "D", "E"], ["A'", "B'", "C'", "D'", "E'"]],
        nine: [[null, "0", "0", "0", null],
                         ["0", "A1", "B1", "C1", "0"],
                         ["0", "A2", "B2", "C2", "0"],
                         ["0", "A3", "B3", "C3", "0"],
                         [null, "0", "0", "0", null]
                       ],
      };
      helpers.setGlobals();
      function loadCanvas() {
        backLayer = new Layer({name: "background"});
        helpers.createBackground();
        contentLayer = new Layer({name: "content"});
        helpers.saveState(contentLayer);
        contentLayer.activate();
        var myRect = protos.rect.clone().set({
          fillColor: "orange",
          position: new Point(200,200),
          scaling: new Size(80,100)
        });
        contentLayer.addChild(myRect);
        var myDot = protos.disc.clone().set({
          fillColor: "green",
          strokeWidth: 3,
          position: new Point(200,100),
          scaling: new Size(10,10),
        });
        contentLayer.addChild(myDot);
        helpers.saveState(contentLayer);
        helpers.toDisplayString(contentLayer);
        globals.openSettings(myDot.id, [
          {propName: "strokeColor", currentVal: myDot.strokeColor.toCSS(true), inputType: "color"},
          {propName: "fillColor", currentVal: myDot.fillColor.toCSS(true), inputType: "color"},
          {propName: "strokeWidth", currentVal: myDot.strokeWidth, inputType: "range", min: 1, max: 10},
        ]);

        var myGraph = newGraph({edgeValues: {isDirected: true,},});
        var node1 = myGraph.addNode(new Point(400,200), "N1");
        var node2 = myGraph.addNode(new Point(480, 200), "N2");
        myGraph.addEdge(node1, node2);
      }

      loadCanvas();

      function newGraph(args) {
        // Args: nodeValues, edgeValues, labelValues
      	var nodes = new Group({name: "nodes"});
        var edges = new Group({name: "edges"});
        var g = new Group({
          children: [nodes, edges],
          addNode: function(point, label) {
            var newNode, newLabel;
            var nodeSym = this.data.nodeValues ? this.data.nodeValues.symbol : null;
            var shift = this.data.defaultShift ? this.data.defaultShift : new Point(0,0);
            if (label) {
              newLabel = new PointText({
                point: point + shift,
                content: label,
                justification: "center",
                data: {shiftable: true,},
                style: (this.data.labelValues && this.data.labelValues.style) ?
                        this.data.labelValues.style : styles.text,
              });
            }
            if (nodeSym) {
              newNode = nodeSym.place(point); // Or clone path.
              var decor = helpers.addDependency(newNode, newLabel, {}); // {offset: shift}
              this.addChild(decor);
            } else if (newLabel) {
              newNode = newLabel;
            } else {
              return false;
            }
            newNode.data.label = newLabel;
            newNode.data.graph = this;
            this.children["nodes"].addChild(newNode);
            return newNode;
          },
          getNodeAt: function(point, tolerance, args) {
            var tol = tolerance ? tolerance : 20;
            var nodeHit = this.children["nodes"].hitTest(point, {
              tolerance: tol,
              fill: true,
              stroke: true,
            });
            if (!nodeHit || !nodeHit.item) {
              return null;
            }
            var retItem = nodeHit.item;
            if (retItem.name === "nodes") {
              return null;
            }
            return retItem;
          },
          addEdge: function(node1, node2) { // Too much packaged here.
            var nodes = [node1, node2];
            var nodeGrp = this.children["nodes"];
            if (!node1.isDescendant(nodeGrp) || !node2.isDescendant(nodeGrp)) {
              return;
            }
            project.currentStyle = (this.data.edgeValues && this.data.edgeValues.style) ?
              this.data.edgeValues.style : styles.stroke;
            var newEdge = helpers.lineFromTo(node1, node2);
            if (this.data.edgeValues && this.data.edgeValues.isDirected) {
              var decor = helpers.addDependency(newEdge, protos.arrow.clone(), {curveTime: 1});
              decor.style = project.currentStyle;
              if (this.data.edgeValues && this.data.edgeValues.arrowFill) {
                decor.fillColor = decor.strokeColor;
              }
              this.addChild(decor);
              decor.bringToFront();
              if (this.data.edgeValues && this.data.edgeValues.hasCrossbars) {
                var decor = helpers.addDependency(newEdge, protos.tick.clone(), {curveTime: 0});
                decor.style = project.currentStyle;
                this.addChild(decor);
                decor.bringToFront();
              }
            }
            newEdge.data.endpoints = [node1, node2]; // Redundant.
            newEdge.data.n1 = node1;
            newEdge.data.n2 = node2;
            helpers.updateDependency(newEdge);
            for (var i=0; i<2; i++) {
              if (!nodes[i].data.dependents) {
                nodes[i].data.dependents = [];
              }
              nodes[i].data.dependents.push(newEdge);
            }
            newEdge.firstSegment.locked = true;
            newEdge.lastSegment.locked = true;
            newEdge.data.bendable = true;
            this.children["edges"].addChild(newEdge);
            return newEdge;
          },
          updateEdges: function(node) {
            var g = this;
            var edge;
            var incomingEdges = g.children["edges"].getItems({
              data: {
                n1: node,
              }
            });
            var outgoingEdges = g.children["edges"].getItems({
              data: {
                n2: node,
              }
            });
            for (var i=0; i < incomingEdges.length; i++) {
              edge = incomingEdges[i];
              helpers.updateDependency(edge);
              helpers.updateAllDependents(edge);
            }
            for (var i=0; i < incomingEdges.length; i++) {
              edge = outgoingEdges[i];
              helpers.updateDependency(edge);
              helpers.updateAllDependents(edge);
            }
          },
          data: {
            nodes: nodes.children,
            edges: edges.children,
            nodeValues: args ? args.nodeValues : null, // Args: symbol, mouseEvents
            edgeValues: args ? args.edgeValues : null, // Args: style, isDirected, arrowFill, arrowSize, hasCrossbars
            labelValues: args ? args.labelValues : null, // Args: style, locked, defaultShift
          },
        });
      	return g;
      }

      function defaultMode(event, isDown) {
        hitResult = project.hitTest(event.point, basics.hitOptions);
        if (hitResult) {
          if (hitResult.type === "bounds" && hitResult.item.data.resizeable) {
            if (hitResult.name === "top-center" || hitResult.name === "bottom-center") {
              view.element.style.cursor = "ns-resize";
            } else if (hitResult.name === "right-center" || hitResult.name === "left-center") {
              view.element.style.cursor = "ew-resize";
            } else if (hitResult.name === "bottom-right" || hitResult.name === "top-left") {
              view.element.style.cursor = "nwse-resize";
            } else if (hitResult.name === "top-right" || hitResult.name === "bottom-left") {
              view.element.style.cursor = "nesw-resize";
            }
            if (isDown) {
              // Determine what point to scale about, and whether or not it should be radial.
              var oppCorner = basics.oppositeCorners[hitResult.name];
              activeItem = hitResult.item;
              tool.onMouseDrag = function(event) {
                handlers.dragToResize(event, activeItem.bounds.oppCorner);
              };
              //tool.onMouseUp = handlers.clearVariables;
            }
          } else if (hitResult.item && (hitResult.item.data.shiftable || hitResult.item.data.bendable)) {
            if (isDown) {
              view.element.style.cursor = "grabbing";
              if (hitResult.type === "stroke" && hitResult.item.data.bendable) {
                var location = hitResult.location;
          			activeItem = hitResult.item.insert(location.index + 1, event.point);
                activeItem.smooth();
              } else if (hitResult.type === "segment" && hitResult.item.data.bendable) {
                activeItem = hitResult.segment;
              } else {
                activeItem = hitResult.item;
              }
              tool.onMouseDrag = handlers.dragToMove;
              //tool.onMouseUp = handlers.clearVariables;
            } else {
              view.element.style.cursor = "grab";
            }
          }
        } else {
          view.element.style.cursor = "default";
        }
      }

      tool.onMouseMove = function(event) {
        defaultMode(event, false);
      }
      tool.onMouseDown = function(event) {
        defaultMode(event, true);
      };

      function onMouseUp(event) {

        if (tool.onMouseDrag == handlers.dragToDraw) {
          activeItem.simplify();
        }
        if (event.modifiers.shift) {
          return;
        }
        if (activeItem) {
          activeItem = null;
          defaultMode(event, false);
        }
        tool.onMouseDrag = null;
        return null;
      }
    </script>
    <script type="text/javascript" src="calculator-display.js"></script>
  </head>
  <body>
    <div class="topnav">
      <a href="about.html">About</a>
      <a href="braids.html">Braids</a>
      <a href="commutative-diagram.html">Snake Lemma</a>
      <a href="dihedral.html">Dihedral group</a>
      <a href="graphs.html">Graph theory</a>
      <a href="siegelPlane.html">Siegel Plane</a>
      <a href="topology.html">Topology</a>
    </div>
    <div>
      <div class="row">
        <canvas id="myCanvas" resize="true" style="border: 1px solid #000">
          This text is displayed if your browser does not support HTML5.
        </canvas>
        <div class="button-bar">
          <button class="mode-button">
            <i class="fas fa-mouse-pointer"></i>
          </button>
          <button class="mode-button"><i class="fas fa-marker"></i></button>
          <button class="mode-button"><i class="fas fa-eraser"></i></button>
          <button class="mode-button">
            <i class="fas fa-hand-sparkles"></i>
          </button>
          <button class="mode-button"><i class="far fa-clone"></i></button>
          <button class="mode-button">
            <i class="fas fa-eye-dropper"></i>
          </button>
          <button class="mode-button"><i class="fas fa-ruler"></i></button>
          <button class="mode-button">
            <i class="fas fa-draw-polygon"></i>
          </button>
          <button class="mode-button">
            <i class="far fa-square"></i>
          </button>
          <button class="mode-button">
            <i class="far fa-circle"></i>
          </button>
          <button class="mode-button"><i class="fas fa-share-alt"></i></button>
        </div>
        <div id="calcDisplay">
          <div id="calcHeader">
            <p>
              <button><i class="fa fa-angle-double-right"></i></button>
              Expression List <button><i class="fa fa-undo"></i></button>
              <button><i class="fa fa-caret-right"></i></button>
            </p>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
